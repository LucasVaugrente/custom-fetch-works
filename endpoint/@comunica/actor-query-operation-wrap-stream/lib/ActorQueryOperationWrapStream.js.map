{"version":3,"file":"ActorQueryOperationWrapStream.js","sourceRoot":"","sources":["ActorQueryOperationWrapStream.ts"],"names":[],"mappings":";;;AAMA,uEAAoE;AACpE,yCAAsE;AAOtE;;GAEG;AACH,MAAa,6BAA8B,SAAQ,yCAAmB;IAIpE,YAAmB,IAAwC;QACzD,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAA6B;QAC7C,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,2CAAmC,CAAC,KAAK,MAAM,CAAC,SAAS,EAAE,CAAC;YACjF,OAAO,IAAA,eAAQ,EAAC,4CAA4C,CAAC,CAAC;QAChE,CAAC;QACD,mDAAmD;QACnD,OAAO,IAAA,eAAQ,EAAC,EAAE,YAAY,EAAE,MAAM,CAAC,iBAAiB,EAAE,CAAC,CAAC;IAC9D,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAA6B;QAC5C,kGAAkG;QAClG,0DAA0D;QAC1D,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;QAC1E,MAAM,MAAM,GAA0B,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACxF,QAAQ,MAAM,CAAC,IAAI,EAAE,CAAC;YACpB,KAAK,UAAU,CAAC,CAAC,CAAC;gBAChB,MAAM,0BAA0B,GAAG,MAAM,IAAI,CAAC,yBAAyB,CAAC,OAAO,CAC7E;oBACE,IAAI,EAAE,UAAU;oBAChB,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,IAAI;oBAChC,MAAM,EAAE,MAAM,CAAC,cAAc;oBAC7B,QAAQ,EAAE,MAAM,CAAC,QAAQ;oBACzB,cAAc,EAAE,MAAM;oBACtB,OAAO,EAAE,MAAM,CAAC,OAAO;iBACxB,CACF,CAAC;gBACF,MAAM,CAAC,cAAc;oBACW,0BAA0B,CAAC,MAAM,CAAC;gBAClE,MAAM,CAAC,QAAQ;oBACqB,0BAA0B,CAAC,QAAQ,CAAC;gBACxE,MAAM;YACR,CAAC;YACD,KAAK,OAAO,CAAC,CAAC,CAAC;gBACb,MAAM,mBAAmB,GAAG,MAAM,IAAI,CAAC,yBAAyB,CAAC,OAAO,CACtE;oBACE,IAAI,EAAE,OAAO;oBACb,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,IAAI;oBAChC,MAAM,EAAE,MAAM,CAAC,UAAU;oBACzB,QAAQ,EAAE,MAAM,CAAC,QAAQ;oBACzB,OAAO,EAAE,MAAM,CAAC,OAAO;oBACvB,cAAc,EAAE,MAAM;iBACvB,CACF,CAAC;gBACF,MAAM,CAAC,UAAU,GAA6B,mBAAmB,CAAC,MAAM,CAAC;gBACzE,MAAM,CAAC,QAAQ,GAAkC,mBAAmB,CAAC,QAAQ,CAAC;gBAC9E,MAAM;YACR,CAAC;YACD,OAAO,CAAC,CAAC,CAAC;gBACR,MAAM;YACR,CAAC;QACH,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACI,iBAAiB,CAAC,SAA4B,EAAE,OAAuB;QAC5E,OAAO,OAAO,CAAC,GAAG,CAAC,2CAAmC,EAAE,SAAS,CAAC,CAAC;IACrE,CAAC;CACF;AAtED,sEAsEC;AAaD;;GAEG;AACU,QAAA,mCAAmC,GAAG,IAAI,uBAAgB,CACrE,yCAAyC,CAC1C,CAAC","sourcesContent":["import type { MediatorIteratorTransform } from '@comunica/bus-iterator-transform';\nimport type {\n  IActionQueryOperation,\n  IActorQueryOperationArgs,\n  MediatorQueryOperation,\n} from '@comunica/bus-query-operation';\nimport { ActorQueryOperation } from '@comunica/bus-query-operation';\nimport { ActionContextKey, failTest, passTest } from '@comunica/core';\nimport type { TestResult, IActorTest } from '@comunica/core';\nimport type { IActionContext, IQueryOperationResult, MetadataBindings, MetadataQuads } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Wrap Stream Query Operation Actor.\n */\nexport class ActorQueryOperationWrapStream extends ActorQueryOperation {\n  public readonly mediatorIteratorTransform: MediatorIteratorTransform;\n  public readonly mediatorQueryOperation: MediatorQueryOperation;\n\n  public constructor(args: IActorQueryOperationWrapStreamArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionQueryOperation): Promise<TestResult<IActorTest>> {\n    if (action.context.get(KEY_CONTEXT_WRAPPED_QUERY_OPERATION) === action.operation) {\n      return failTest('Unable to wrap query source multiple times');\n    }\n    // Ensure this is always run if not already wrapped\n    return passTest({ httpRequests: Number.NEGATIVE_INFINITY });\n  }\n\n  public async run(action: IActionQueryOperation): Promise<IQueryOperationResult> {\n    // Prevent infinite recursion. In consequent query operation calls this key should be set to false\n    // To allow the operation to wrap ALL query operation runs\n    action.context = this.setContextWrapped(action.operation, action.context);\n    const output: IQueryOperationResult = await this.mediatorQueryOperation.mediate(action);\n    switch (output.type) {\n      case 'bindings': {\n        const bindingIteratorTransformed = await this.mediatorIteratorTransform.mediate(\n          {\n            type: 'bindings',\n            operation: action.operation.type,\n            stream: output.bindingsStream,\n            metadata: output.metadata,\n            originalAction: action,\n            context: action.context,\n          },\n        );\n        output.bindingsStream =\n          <AsyncIterator<RDF.Bindings>> bindingIteratorTransformed.stream;\n        output.metadata =\n          <() => Promise<MetadataBindings>> bindingIteratorTransformed.metadata;\n        break;\n      }\n      case 'quads': {\n        const iteratorTransformed = await this.mediatorIteratorTransform.mediate(\n          {\n            type: 'quads',\n            operation: action.operation.type,\n            stream: output.quadStream,\n            metadata: output.metadata,\n            context: action.context,\n            originalAction: action,\n          },\n        );\n        output.quadStream = <AsyncIterator<RDF.Quad>> iteratorTransformed.stream;\n        output.metadata = <() => Promise<MetadataQuads>> iteratorTransformed.metadata;\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Sets KEY_CONTEXT_WRAPPED_QUERY_OPERATION to the operation being executed.\n   * @param operation The query operation.\n   * @param context The current action context.\n   * @returns A new action context with the operation marked as wrapped.\n   */\n  public setContextWrapped(operation: Algebra.Operation, context: IActionContext): IActionContext {\n    return context.set(KEY_CONTEXT_WRAPPED_QUERY_OPERATION, operation);\n  }\n}\n\nexport interface IActorQueryOperationWrapStreamArgs extends IActorQueryOperationArgs {\n  /**\n   * Mediator that runs all transforms defined by user over the output stream of the query operation\n   */\n  mediatorIteratorTransform: MediatorIteratorTransform;\n  /**\n   * Mediator that runs the next query operation\n   */\n  mediatorQueryOperation: MediatorQueryOperation;\n}\n\n/**\n * Key that that stores the last executed operation\n */\nexport const KEY_CONTEXT_WRAPPED_QUERY_OPERATION = new ActionContextKey<Algebra.Operation>(\n  '@comunica/actor-query-operation:wrapped',\n);\n"]}