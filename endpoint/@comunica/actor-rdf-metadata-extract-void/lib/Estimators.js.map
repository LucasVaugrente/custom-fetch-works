{"version":3,"file":"Estimators.js","sourceRoot":"","sources":["Estimators.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { RDF_TYPE } from './Definitions';\nimport type { IVoidDataset } from './Types';\n\n/**\n * Estimate the cardinality of the provided operation using the specified dataset metadata.\n * This is the primary function that should be called to perform\n */\nexport function getCardinality(dataset: IVoidDataset, operation: Algebra.Operation): RDF.QueryResultCardinality {\n  switch (operation.type) {\n    case Algebra.types.PROJECT:\n    case Algebra.types.FILTER:\n    case Algebra.types.ORDER_BY:\n    case Algebra.types.GROUP:\n    case Algebra.types.CONSTRUCT:\n      return getCardinality(dataset, operation.input);\n    case Algebra.types.PATTERN:\n      return getPatternCardinality(dataset, operation);\n    case Algebra.types.BGP:\n      return getJoinCardinality(dataset, operation.patterns);\n    case Algebra.types.JOIN:\n      return getJoinCardinality(dataset, operation.input);\n    case Algebra.types.GRAPH:\n      return getGraphCardinality(dataset, operation);\n    case Algebra.types.FROM:\n      return getFromCardinality(dataset, operation);\n    case Algebra.types.SLICE:\n      return getSliceCardinality(dataset, operation);\n    case Algebra.types.MINUS:\n      return getMinusCardinality(dataset, operation);\n    case Algebra.types.VALUES:\n      return { type: 'exact', value: operation.bindings.length };\n    default:\n      return { type: 'estimate', value: Number.POSITIVE_INFINITY };\n  }\n}\n\n/**\n * Estimate triple pattern cardinality, by first applying heuristics based on void:uriPatternRegex\n * and void:vocabulary data when available, before performing estimations using the formulae.\n */\nexport function getPatternCardinality(dataset: IVoidDataset, pattern: Algebra.Pattern): RDF.QueryResultCardinality {\n  const estimate: RDF.QueryResultCardinality = { type: 'exact', value: 0 };\n  if (matchPatternVocabularies(dataset, pattern) && matchPatternResourceUris(dataset, pattern)) {\n    const value = getPatternCardinalityRaw(dataset, pattern);\n    if (value > 0) {\n      estimate.value = value;\n      estimate.type = 'estimate';\n    }\n  }\n  return estimate;\n}\n\n/**\n * Estimate the cardinality of a minus, by taking into account the input cardinalities.\n */\nexport function getMinusCardinality(dataset: IVoidDataset, minus: Algebra.Minus): RDF.QueryResultCardinality {\n  const estimateFirst = getCardinality(dataset, minus.input[0]);\n  const estimateSecond = getCardinality(dataset, minus.input[1]);\n  return { type: 'estimate', value: Math.max(estimateFirst.value - estimateSecond.value, 0) };\n}\n\n/**\n * Estimate the cardinality of a slice operation, taking into account the input cardinality and the slice range.\n */\nexport function getSliceCardinality(dataset: IVoidDataset, slice: Algebra.Slice): RDF.QueryResultCardinality {\n  const estimate = getCardinality(dataset, slice.input);\n  if (estimate.value > 0) {\n    estimate.value = Math.max(estimate.value - slice.start, 0);\n    if (slice.length !== undefined) {\n      estimate.value = Math.min(estimate.value, slice.length);\n    }\n  }\n  return estimate;\n}\n\n/**\n * Estimate the cardinality of a from statement, by checking if any of the declared graphs\n * match the current one, and then returning the appropriate estimate.\n */\nexport function getFromCardinality(dataset: IVoidDataset, from: Algebra.From): RDF.QueryResultCardinality {\n  if (\n    from.default.some(nn => nn.value === dataset.identifier) ||\n    from.named.some(nn => nn.value === dataset.identifier)\n  ) {\n    return getCardinality(dataset, from.input);\n  }\n  return { type: 'exact', value: 0 };\n}\n\n/**\n * Estimate the cardinality of a statement wrapped under a graph, by also checking if the graph exists.\n */\nexport function getGraphCardinality(dataset: IVoidDataset, graph: Algebra.Graph): RDF.QueryResultCardinality {\n  if (graph.name.termType === 'Variable' || graph.name.value === dataset.identifier) {\n    return getCardinality(dataset, graph.input);\n  }\n  return { type: 'exact', value: 0 };\n}\n\n/**\n * Estimate the cardinality of a join, using a sum of the individual input cardinalities.\n * This should result in a somewhat acceptable estimate that will likely be above the probable join plan,\n * but still below an unreasonably high and unlikely cartesian estimate.\n */\nexport function getJoinCardinality(dataset: IVoidDataset, operations: Algebra.Operation[]): RDF.QueryResultCardinality {\n  const estimate: RDF.QueryResultCardinality = { type: 'exact', value: 0 };\n  for (const input of operations) {\n    const cardinality = getCardinality(dataset, input);\n    if (cardinality.value > 0) {\n      estimate.type = 'estimate';\n      estimate.value += cardinality.value;\n    }\n  }\n  return estimate;\n}\n\n/**\n * Test whether the given albegra pattern could produce answers from a dataset with the specified resourceUriPattern.\n * Specifically, if both subject and object are IRIs, but neither matches the resourceUriPattern,\n * then the dataset does not contain any RDF resources that would satisfy the pattern.\n */\nexport function matchPatternResourceUris(dataset: IVoidDataset, pattern: Algebra.Pattern): boolean {\n  return (\n    !dataset.uriRegexPattern ||\n    (pattern.subject.termType !== 'NamedNode' || dataset.uriRegexPattern.test(pattern.subject.value)) ||\n    (pattern.object.termType !== 'NamedNode' || dataset.uriRegexPattern.test(pattern.object.value))\n  );\n}\n\n/**\n * Test whether the given algebra pattern could produce answers from a dataset with the specified vocabularies.\n * Specifically, if the predicate if an IRI but it does not use any of the specifiec vocabularies,\n * then the pattern cannot be answered by the dataset.\n */\nexport function matchPatternVocabularies(dataset: IVoidDataset, pattern: Algebra.Pattern): boolean {\n  if (dataset.vocabularies !== undefined && pattern.predicate.termType === 'NamedNode') {\n    return dataset.vocabularies.some(vc => pattern.predicate.value.startsWith(vc));\n  }\n  return true;\n}\n\n/**\n * Estimate the triple pattern cardinality using the formulae from Hagedorn, Stefan, et al.\n * \"Resource Planning for SPARQL Query Execution on Data Sharing Platforms.\" COLD 1264 (2014)\n */\nexport function getPatternCardinalityRaw(dataset: IVoidDataset, pattern: Algebra.Pattern): number {\n  // ?s rdf:type <o> (from the original paper)\n  // ?s rdf:type _:o (also accounted for)\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'NamedNode' &&\n    pattern.predicate.value === RDF_TYPE &&\n    (pattern.object.termType === 'NamedNode' || pattern.object.termType === 'BlankNode')\n  ) {\n    return getClassPartitionEntities(dataset, pattern.object);\n  }\n  // ?s ?p ?o (from the original paper)\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'Variable' &&\n    pattern.object.termType === 'Variable'\n  ) {\n    return dataset.triples;\n  }\n  // <s> ?p ?o (from the original paper)\n  // _:s ?p ?o (also accounted for)\n  // <s> ?p \"o\"\n  // _:s ?p \"o\"\n  if (\n    (pattern.subject.termType === 'NamedNode' || pattern.subject.termType === 'BlankNode') &&\n    pattern.predicate.termType === 'Variable' &&\n    (pattern.object.termType === 'Variable' || pattern.object.termType === 'Literal')\n  ) {\n    const distinctSubjects = getDistinctSubjects(dataset);\n    if (distinctSubjects > 0) {\n      return dataset.triples / distinctSubjects;\n    }\n  }\n  // ?s <p> ?o (from the original paper)\n  // ?s <p> \"o\" (also accounted for)\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'NamedNode' &&\n    (pattern.object.termType === 'Variable' || pattern.object.termType === 'Literal')\n  ) {\n    return getPredicateTriples(dataset, pattern.predicate);\n  }\n  // ?s ?p <o> (from the original paper)\n  // ?s ?p _:o (also accounted for)\n  // ?s ?p \"o\"\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'Variable' &&\n    (\n      pattern.object.termType === 'NamedNode' ||\n      pattern.object.termType === 'BlankNode' ||\n      pattern.object.termType === 'Literal'\n    )\n  ) {\n    const distinctObjects = getDistinctObjects(dataset);\n    if (distinctObjects > 0) {\n      return dataset.triples / distinctObjects;\n    }\n  }\n  // <s> <p> ?o (from the original paper)\n  // _:s <p> ?o (also accounted for)\n  // <s> <p> \"o\"\n  // _:s <p> \"o\"\n  if (\n    (pattern.subject.termType === 'NamedNode' || pattern.subject.termType === 'BlankNode') &&\n    pattern.predicate.termType === 'NamedNode' &&\n    (pattern.object.termType === 'Variable' || pattern.object.termType === 'Literal')\n  ) {\n    const predicateTriples = getPredicateTriples(dataset, pattern.predicate);\n    const predicateSubjects = getPredicateSubjects(dataset, pattern.predicate);\n    return predicateSubjects > 0 ? predicateTriples / predicateSubjects : predicateTriples;\n  }\n  // <s> ?p <o> (from the original paper)\n  // _:s ?p _:o (also accounted for)\n  // _:s ?p <o>\n  // <s> ?p _:o\n  if (\n    (pattern.subject.termType === 'NamedNode' || pattern.subject.termType === 'BlankNode') &&\n    pattern.predicate.termType === 'Variable' &&\n    (pattern.object.termType === 'NamedNode' || pattern.object.termType === 'BlankNode')\n  ) {\n    const distinctSubjects = getDistinctSubjects(dataset);\n    const distinctObjects = getDistinctObjects(dataset);\n    if (distinctSubjects > 0 && distinctObjects > 0) {\n      return dataset.triples / (distinctSubjects * distinctObjects);\n    }\n  }\n  // ?s <p> <o> (from the original paper)\n  // ?s <p> _:o (also accounted for)\n  if (\n    pattern.subject.termType === 'Variable' &&\n    pattern.predicate.termType === 'NamedNode' &&\n    (pattern.object.termType === 'NamedNode' || pattern.object.termType === 'BlankNode')\n  ) {\n    const predicateTriples = getPredicateTriples(dataset, pattern.predicate);\n    const predicateObjects = getPredicateObjects(dataset, pattern.predicate);\n    return predicateObjects > 0 ? predicateTriples / predicateObjects : predicateTriples;\n  }\n  // <s> <p> <o> (from the original paper)\n  // _:s <p> _:o (also accounted for)\n  // <s> <p> _:o\n  // _:s <p> <o>\n  if (\n    (pattern.subject.termType === 'NamedNode' || pattern.subject.termType === 'BlankNode') &&\n    pattern.predicate.termType === 'NamedNode' &&\n    (pattern.object.termType === 'NamedNode' || pattern.object.termType === 'BlankNode')\n  ) {\n    const predicateTriples = getPredicateTriples(dataset, pattern.predicate);\n    const predicateSubjects = getPredicateSubjects(dataset, pattern.predicate);\n    const predicateObjects = getPredicateObjects(dataset, pattern.predicate);\n    return predicateSubjects > 0 && predicateObjects > 0 ?\n      predicateTriples / (predicateSubjects * predicateObjects) :\n      predicateTriples;\n  }\n\n  // In all other cases, return the total triple count as absolute upper bound\n  return dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:distinctObjects, falls back to void:entities.\n * Returns the total triple count as fallback upper bound.\n */\nexport function getDistinctObjects(dataset: IVoidDataset): number {\n  return dataset.distinctObjects ?? dataset.entities ?? dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:distinctSubjects, falls back to void:entities.\n * Returns the total triple count as fallback upper bound.\n */\nexport function getDistinctSubjects(dataset: IVoidDataset): number {\n  return dataset.distinctSubjects ?? dataset.entities ?? dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:distinctObjects from a void:propertyPartition.\n * Returns 0 when property partitions are available but the specific property is not.\n * Falls back to total triple count as upper bound without any property partitions.\n */\nexport function getPredicateObjects(dataset: IVoidDataset, predicate: RDF.NamedNode): number {\n  if (dataset.propertyPartitions) {\n    const partition = dataset.propertyPartitions[predicate.value];\n    return partition?.distinctObjects ?? partition?.triples ?? 0;\n  }\n  return dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:distinctSubjects from a void:propertyPartition.\n * Returns 0 when property partitions are available but the specific property is not.\n * Falls back to total triple count as upper bound without any property partitions.\n */\nexport function getPredicateSubjects(dataset: IVoidDataset, predicate: RDF.NamedNode): number {\n  if (dataset.propertyPartitions) {\n    const partition = dataset.propertyPartitions[predicate.value];\n    return partition?.distinctSubjects ?? partition?.triples ?? 0;\n  }\n  return dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:triples from a void:propertyPartition.\n * Returns 0 when property partitions are available but the specific property is not.\n * Falls back to total triple count as upper bound without any property partitions.\n */\nexport function getPredicateTriples(dataset: IVoidDataset, predicate: RDF.NamedNode): number {\n  if (dataset.propertyPartitions) {\n    return dataset.propertyPartitions[predicate.value]?.triples ?? 0;\n  }\n  return dataset.triples;\n}\n\n/**\n * Attempts to retrieve void:entities from a void:classPartition.\n * Returns 0 when class partitions are available but the specified class is not.\n * Falls back to estimation using void:entities and void:classes on the dataset,\n * and finally total dataset triple count as upper bound.\n */\nexport function getClassPartitionEntities(dataset: IVoidDataset, object: RDF.NamedNode | RDF.BlankNode): number {\n  if (dataset.classPartitions) {\n    return dataset.classPartitions[object.value]?.entities ?? 0;\n  }\n  if (dataset.entities !== undefined && dataset.classes) {\n    return dataset.entities / dataset.classes;\n  }\n  return dataset.triples;\n}\n"]}