{"version":3,"file":"ActorIteratorTransform.js","sourceRoot":"","sources":["ActorIteratorTransform.ts"],"names":[],"mappings":";;;AACA,yCAAiD;AAMjD;;;;;;;;;;;GAWG;AACH,MAAsB,sBACpB,SAAQ,YAA4E;IAEpF;;OAEG;IACH,YAAmB,IAAqC;QACtD,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAA+B;QAE9C,IAAI,MAAM,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;YAC/B,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC,CAAC;YAC1E,OAAO;gBACL,IAAI,EAAE,MAAM,CAAC,IAAI;gBACjB,SAAS,EAAE,MAAM,CAAC,SAAS;gBAC3B,MAAM;gBACN,QAAQ;gBACR,cAAc,EAAE,MAAM,CAAC,cAAc;gBACrC,OAAO,EAAE,MAAM,CAAC,OAAO;aACxB,CAAC;QACJ,CAAC;QAED,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;QACvE,OAAO;YACL,IAAI,EAAE,MAAM,CAAC,IAAI;YACjB,SAAS,EAAE,MAAM,CAAC,SAAS;YAC3B,MAAM;YACN,QAAQ;YACR,cAAc,EAAE,MAAM,CAAC,cAAc;YACrC,OAAO,EAAE,MAAM,CAAC,OAAO;SACxB,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,IAAI,CACf,MAA+B;QAE/B,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;YACzD,OAAO,IAAA,eAAQ,EAAC,oDAAoD,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QACnF,CAAC;QACD,OAAO,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;CAUF;AApDD,wDAoDC","sourcesContent":["import type { IAction, IActorArgs, IActorOutput, IActorTest, Mediate, TestResult } from '@comunica/core';\nimport { Actor, failTest } from '@comunica/core';\nimport type { LogicalJoinType, IActionContext, MetadataBindings, MetadataQuads } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport type { types } from 'sparqlalgebrajs/lib/algebra';\n\n/**\n * A comunica actor for transform-iterator events.\n *\n * Actor types:\n *  Input:  IActionIteratorTransform: Data that denotes what type of stream is being wrapped,\n *   what actor produced this stream, and the stream itself\n * * Test:   <none>\n * * Output: IActorIteratorTransformOutput: The transformed stream and additional metadata.\n *\n * @see IActionIteratorTransform\n * @see IActorIteratorTransformOutput\n */\nexport abstract class ActorIteratorTransform<TS = undefined>\n  extends Actor<ActionIteratorTransform, IActorTest, ActorIteratorTransformOutput, TS> {\n  public wraps: possibleOperationTypes[];\n  /**\n   * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus\n   */\n  public constructor(args: IActorIteratorTransformArgs<TS>) {\n    super(args);\n  }\n\n  public async run(action: ActionIteratorTransform):\n  Promise<ActorIteratorTransformOutput> {\n    if (action.type === 'bindings') {\n      const { stream, metadata } = await this.transformIteratorBindings(action);\n      return {\n        type: action.type,\n        operation: action.operation,\n        stream,\n        metadata,\n        originalAction: action.originalAction,\n        context: action.context,\n      };\n    }\n\n    const { stream, metadata } = await this.transformIteratorQuads(action);\n    return {\n      type: action.type,\n      operation: action.operation,\n      stream,\n      metadata,\n      originalAction: action.originalAction,\n      context: action.context,\n    };\n  }\n\n  public async test(\n    action: ActionIteratorTransform,\n  ): Promise<TestResult<IActorTest, TS>> {\n    if (this.wraps && !this.wraps.includes(action.operation)) {\n      return failTest(`Operation type not supported in configuration of ${this.name}`);\n    }\n    return this.testIteratorTransform(action);\n  }\n\n  protected abstract testIteratorTransform(action: ActionIteratorTransform):\n  Promise<TestResult<IActorTest, TS>>;\n\n  public abstract transformIteratorBindings(action: IActionIteratorTransformBindings):\n  Promise<ITransformIteratorOutput<AsyncIterator<RDF.Bindings>, MetadataBindings>>;\n\n  public abstract transformIteratorQuads(action: IActionIteratorTransformQuads):\n  Promise<ITransformIteratorOutput<AsyncIterator<RDF.Quad>, MetadataQuads>>;\n}\n\nexport interface IActionIteratorTransform<T extends 'bindings' | 'quads', S, M> extends IAction {\n  /**\n   * Whether the stream produces bindings or quads\n   */\n  type: T;\n  /**\n   * The operation that produced the stream\n   */\n  operation: possibleOperationTypes;\n  /**\n   * The stream to be transformed by the actor\n   */\n  stream: S;\n  /**\n   * Stream metadata\n   */\n  metadata: () => Promise<M>;\n  /**\n   * Action that produced the stream\n   */\n  originalAction: IAction;\n}\n\nexport interface IActionIteratorTransformBindings\n  extends IActionIteratorTransform<'bindings', AsyncIterator<RDF.Bindings>, MetadataBindings> {\n}\n\nexport interface IActionIteratorTransformQuads\n  extends IActionIteratorTransform<'quads', AsyncIterator<RDF.Quad>, MetadataQuads> {\n}\n\nexport type ActionIteratorTransform = IActionIteratorTransformBindings | IActionIteratorTransformQuads;\n\nexport interface IActorIteratorTransformOutput<T extends 'bindings' | 'quads', S, M> extends IActorOutput {\n  /**\n   * Whether the stream produces bindings or quads\n   */\n  type: T;\n  /**\n   * The operation that produced the stream\n   */\n  operation: possibleOperationTypes;\n  /**\n   * Transformed stream\n   */\n  stream: S;\n  /**\n   * Optionally transformed metadata\n   */\n  metadata: () => Promise<M>;\n  /**\n   * Action that produced the stream\n   */\n  originalAction: IAction;\n  /**\n   * (Unchanged)Context given in action\n   */\n  context: IActionContext;\n}\n\nexport interface IActorIteratorTransformBindingsOutput\n  extends IActorIteratorTransformOutput<'bindings', AsyncIterator<RDF.Bindings>, MetadataBindings> {\n}\n\nexport interface IActorIteratorTransformQuadOutput\n  extends IActorIteratorTransformOutput<'quads', AsyncIterator<RDF.Quad>, MetadataQuads> {\n}\n\nexport type ActorIteratorTransformOutput =\n  IActorIteratorTransformBindingsOutput | IActorIteratorTransformQuadOutput;\n\nexport interface ITransformIteratorOutput<S, M> {\n  /**\n   * Transformed stream\n   */\n  stream: S;\n  /**\n   * Optionally transformed metadata\n   */\n  metadata: () => Promise<M>;\n}\n\nexport interface IActorIteratorTransformArgs<TS = undefined> extends IActorArgs<\n  ActionIteratorTransform,\n  IActorTest,\nActorIteratorTransformOutput,\nTS\n  > {\n  /**\n   * What types of operations the actor will wrap. If undefined the actor wraps every operation\n   */\n  wraps?: possibleOperationTypes[];\n}\n\nexport type possibleOperationTypes = types | LogicalJoinType;\n\nexport type MediatorIteratorTransform =\n  Mediate<\n  ActionIteratorTransform,\n  ActorIteratorTransformOutput\n  >;\n"]}