{"version":3,"file":"toEqualBindingsArray.js","sourceRoot":"","sources":["toEqualBindingsArray.ts"],"names":[],"mappings":";;AAAA,6EAA6F;AAE7F,uDAAgD;AAEhD,SAAS,qBAAqB,CAAC,QAAwB;IACrD,OAAO,KAAK,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAA,yCAAgB,EAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;AAC1E,CAAC;AAED,kBAAe;IACb,oBAAoB,CAAC,QAAwB,EAAE,MAAsB,EAAE,WAAW,GAAG,KAAK;QACxF,IAAI,QAAQ,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAAE,CAAC;YACtC,OAAO;gBACL,OAAO,EAAE,GAAG,EAAE,CAAC,YAAY,qBAAqB,CAAC,QAAQ,CAAC,aAAa,qBAAqB,CAAC,MAAM,CAAC,EAAE;gBACtG,IAAI,EAAE,KAAK;aACZ,CAAC;QACJ,CAAC;QAED,+CAA+C;QAC/C,IAAI,WAAW,EAAE,CAAC;YAChB,MAAM,mBAAmB,GAAG,CAAC,IAAkB,EAAE,KAAmB,EAAU,EAAE,CAC9E,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACxC,MAAM,kBAAkB,GAAG,CAAC,IAAkB,EAAE,KAAmB,EAAU,EAAE,CAC7E,IAAA,gDAAuB,EAAC,IAAI,EAAE,CAAE,GAAG,IAAI,CAAC,IAAI,EAAE,CAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;iBACxE,aAAa,CAAC,IAAA,gDAAuB,EAAC,KAAK,EAAE,CAAE,GAAG,KAAK,CAAC,IAAI,EAAE,CAAE,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC;YAClG,QAAQ,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YAClC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;QAClC,CAAC;QAED,KAAK,MAAM,CAAE,CAAC,EAAE,OAAO,CAAE,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC;YAChD,MAAM,GAAG,GAAG,yBAAe,CAAC,eAAe,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YAChE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;gBACd,OAAO;oBACL,OAAO,EAAE,GAAG,EAAE,CAAC,YAAY,qBAAqB,CAAC,QAAQ,CAAC,aAAa,qBAAqB,CAAC,MAAM,CAAC,WAAW,CAAC,gBAAgB;oBAChI,IAAI,EAAE,KAAK;iBACZ,CAAC;YACJ,CAAC;QACH,CAAC;QAED,OAAO;YACL,OAAO,EAAE,GAAG,EAAE,CAAC,YAAY,qBAAqB,CAAC,QAAQ,CAAC,iBAAiB,qBAAqB,CAAC,MAAM,CAAC,EAAE;YAC1G,IAAI,EAAE,IAAI;SACX,CAAC;IACJ,CAAC;CACF,CAAC","sourcesContent":["import { bindingsToCompactString, bindingsToString } from '@comunica/utils-bindings-factory';\nimport type * as RDF from '@rdfjs/types';\nimport toEqualBindings from './toEqualBindings';\n\nfunction bindingsArrayToString(bindings: RDF.Bindings[]): string {\n  return `[ ${bindings.map(term => bindingsToString(term)).join(', ')} ]`;\n}\n\nexport default {\n  toEqualBindingsArray(received: RDF.Bindings[], actual: RDF.Bindings[], ignoreOrder = false) {\n    if (received.length !== actual.length) {\n      return {\n        message: () => `expected ${bindingsArrayToString(received)} to equal ${bindingsArrayToString(actual)}`,\n        pass: false,\n      };\n    }\n\n    // Sort both streams if order should be ignored\n    if (ignoreOrder) {\n      const comparatorVariables = (left: RDF.Variable, right: RDF.Variable): number =>\n        left.value.localeCompare(right.value);\n      const comparatorBindings = (left: RDF.Bindings, right: RDF.Bindings): number =>\n        bindingsToCompactString(left, [ ...left.keys() ].sort(comparatorVariables))\n          .localeCompare(bindingsToCompactString(right, [ ...right.keys() ].sort(comparatorVariables)));\n      received.sort(comparatorBindings);\n      actual.sort(comparatorBindings);\n    }\n\n    for (const [ i, element ] of received.entries()) {\n      const sub = toEqualBindings.toEqualBindings(element, actual[i]);\n      if (!sub.pass) {\n        return {\n          message: () => `expected ${bindingsArrayToString(received)} to equal ${bindingsArrayToString(actual)}\\nIndex ${i} is different.`,\n          pass: false,\n        };\n      }\n    }\n\n    return {\n      message: () => `expected ${bindingsArrayToString(received)} not to equal ${bindingsArrayToString(actual)}`,\n      pass: true,\n    };\n  },\n};\n"]}